#include <stdio.h>

int *sort(int *arr1, int arr1_len, int *arr2, int arr2_len, int arr[])
{
    // записи int arr1[] и int *arr в аргументах функции - ЭТО ОДНО И ТО ЖЕ.
    // В каждом из этих случаев в функцию передается указатель на первый элемент массива (&arr[0]).

    // так как в дальнейшем я буду перемещать указатели arr1 и arr2 я должен запомнить куда они указывали изначально в двух указателях a1, a2
    int *a1 = arr1; // a1 указывает на начало arr1
    int *a2 = arr2; // a2 указывает на начало arr2

    // элементы массива, который возрастает я перебираю от начала, поэтому arr1 должен указывать на начало
    // а вот второй массив я должен перебираться с конца, поэтому перемещаю указатель на конец массива.
    // сделать это можно только зная длину массива (arr2_len), которую я передал в функцию

    // к указателям можно прибавлять числа.
    // Если arr2 изначально указывал на нулевой элемент, то верно равенство: arr2 + 1 == arr2[1], arr2 + 2 == arr2[2] и тд.
    arr2 += arr2_len - 1; // то есть теперь arr2 указывает на конец массива

    int i =0; // счетчик массива для резултата (arr)

    /* Вкратце описываю алгоритм:

        Так как результирующий массив( далее РМ ) мне нужно отсортировать по возрастанию начинаю с самых маленьких элементов
    - это начало перовго массива (arr1[0]) и конец второго (arr2[ar2_len -1])

        Cравниваю эти элементы. Если arr1[0] < arr2[2], то я кладу в РМ значение arr1[0],
    и перемещаю указатель этого массива на след элемент, чтоб больше не возвращаться к этому.

    На языке указателей это звучит так arr[0](РМ) = *arr1++. *arr1 берет значение arr1[0], a "++" прибавляет к указателю единицу
    Это эквивалентно записям:
    arr[0] = *arr1; // копирую элемент
    arr1 += 1; // перемещаю указатель
    Но дабы всю проверку и присваивание сделать короче я использую инкремент(++).

    Если же arr1[0] > arr2[2], то будет так: arr[0] = *arr2--.
    Все точно так же, НО так второй массив перебираем с конца, указатель нужно уменьшить "--".

        В конце концов возникнет ситуация когда один из массивов полностью просмотрен и тогда я кидаю в РМ оставшиеся элементы из другого массива.
    В коде проверка на этого случая под номерами 1 и 2.

        Если ты знаком с условными выражениями то тебе будет понятно, то что написано в else, но на всякий случай поясню:
    x = (выр1) ? (выр2) : (выр3); - это короткая запись if. Если выр1 верно, то x = выр2, иначе x = выр3.

    */
    while(1)
    {
        if(arr1 == a1 + arr1_len) //1
        {
            while(arr2 >= a2)
                arr[i++] = *arr2--;
            return arr;
        }
        else if(arr2 == a2-1) //2
        {
              while(arr1 <= a1 + arr1_len)
                    arr[i++] = *arr1++;
              return arr;
        }
        else
            arr[i++] = (*arr1 < *arr2) ? *arr1++ : *arr2--;

    }
}

int main()
{
    // В main ничего интересного, только ввод массивов, вызов функции и вывод результата.
    int arr1_len;
    scanf("%d", &arr1_len);
    int arr1[arr1_len];

    for(int i = 0; i< arr1_len; i++)
        scanf("%d", &arr1[i]);

    int arr2_len;
    scanf("%d", &arr2_len);
    int arr2[arr2_len];

    for(int i = 0; i< arr2_len; i++)
        scanf("%d", &arr2[i]);

    int arr[arr1_len+arr2_len]; // массив для результата

    sort(arr1, arr1_len, arr2, arr2_len, arr);

    for(int i = 0; i<arr1_len+arr2_len; i++)
        printf("%d ", arr[i]);

}
